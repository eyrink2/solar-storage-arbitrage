# does not work -- EIA API does not provide the right data but theoretically this works with that

import streamlit as st
import pandas as pd
from datetime import datetime
from arbitrage_api import SolarStorageArbitrage # Import the backend class

def create_sidebar_controls():
    """
    Creates the sidebar control panel for all user-configurable simulation inputs.
    
    Returns:
        dict: A dictionary containing all the parameters set by the user.
    """
    st.sidebar.header("Simulation Inputs")
    
    # --- API Key Input ---
    # Hard-coded API key for convenience
    api_key = ""
    
    # --- Data and System Configuration ---
    st.sidebar.subheader("Market & System")
    price_market = st.sidebar.selectbox("Select Price Market", ["California (CAISO)", "Texas (ERCOT)"])
    solar_size_mw = st.sidebar.slider("Solar System Size (MW)", 50, 500, 100, 10)
    battery_power_mw = st.sidebar.slider("Battery Power (MW)", 25, 250, 50, 5)
    battery_duration_hours = st.sidebar.slider("Battery Duration (Hours)", 2, 6, 4, 1)
    
    # Derived parameter: Battery energy capacity is power * duration.
    battery_capacity_mwh = battery_power_mw * battery_duration_hours
    
    # --- Financial Assumptions ---
    st.sidebar.subheader("Financial Assumptions")
    battery_capex_per_kwh = st.sidebar.slider("Battery CAPEX ($/kWh)", 100, 250, 150, 25)
    round_trip_efficiency = st.sidebar.slider("Round-Trip Efficiency (%)", 80, 95, 90, 1) / 100.0
    
    # --- Action Button ---
    st.sidebar.markdown("---")
    run_simulation = st.sidebar.button("Run Simulation", type="primary", use_container_width=True)
    
    # Return all parameters in a dictionary.
    return {
        'api_key': api_key,
        'price_market': price_market,
        'solar_size_mw': solar_size_mw,
        'battery_power_mw': battery_power_mw,
        'battery_capacity_mwh': battery_capacity_mwh,
        'battery_capex_per_kwh': battery_capex_per_kwh,
        'round_trip_efficiency': round_trip_efficiency,
        'run_simulation': run_simulation
    }

def display_kpi_metrics(results, params):
    """Displays the main Key Performance Indicators in a visually appealing way."""
    st.subheader("Key Performance Indicators")
    
    # Use columns for a clean layout.
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric(
            "Annual Revenue Uplift",
            f"${results['revenues']['uplift_dollars']:,.0f}",
            help="Additional annual revenue generated by adding the battery."
        )
    with col2:
        st.metric(
            "Revenue Increase",
            f"{results['revenues']['uplift_percent']:.1f}%",
            help="The percentage increase in total revenue compared to a standalone solar project."
        )
    with col3:
        # Display total battery cycles as an operational metric
        total_cycles = results['kpis']['total_cycles']
        st.metric(
            "Battery Cycles",
            f"{total_cycles:.0f}",
            help="Total number of battery charge/discharge cycles per year."
        )
    
    # Second row with additional revenue details
    st.markdown("---")
    col5, col6 = st.columns(2)
    
    with col5:
        st.metric(
            "Solar-Only Revenue",
            f"${results['revenues']['solar_only_dollars']:,.0f}",
            help="Annual revenue from solar without battery storage."
        )
    with col6:
        st.metric(
            "Solar+Storage Revenue",
            f"${results['revenues']['total_dollars']:,.0f}",
            help="Total annual revenue with optimized battery arbitrage."
        )

def main():
    """
    Main function to configure the Streamlit page and orchestrate the
    simulation and display of results.
    """
    # --- Page Configuration ---
    st.set_page_config(
        page_title="Solar + Storage Arbitrage Calculator",
        page_icon="ðŸ”‹",
        layout="wide"
    )
    
    # --- Header ---
    st.title("Solar + Storage Arbitrage Value Calculator")
    st.markdown("This tool quantifies the economic value of adding battery storage to a solar farm by simulating an energy arbitrage strategy against real-world, hourly electricity prices from the EIA.")
    
    # --- Sidebar and User Inputs ---
    params = create_sidebar_controls()
    
    # --- Simulation Execution Logic ---
    if params['run_simulation']:
        # **Critical Step**: Validate that the API key has been entered.
        if not params['api_key']:
            st.error("EIA API Key is required. Please enter your key in the sidebar to run the simulation.")
        else:
            # Use a spinner to provide feedback during the (potentially long) API call and simulation.
            with st.spinner("Fetching real-world price data from EIA and running simulation..."):
                try:
                    # 1. Initialize the model with the user's API key.
                    model = SolarStorageArbitrage(api_key=params['api_key'])
                    
                    # 2. Load the real-world price data.
                    price_data = model.load_price_data(params['price_market'], year=2023)
                    
                    # 3. Check if the API call was successful.
                    if price_data.empty:
                        st.error("Failed to fetch data. This could be due to an invalid API key, network issues, or no data for the selected period. Please try again.")
                    else:
                        # 4. Generate the corresponding solar profile.
                        solar_profile = model.generate_solar_profile(peak_mw=params['solar_size_mw'])
                        
                        # 5. Run the core simulation.
                        results = model.run_simulation(solar_profile, params)


                        print("\n=== DEBUG INFO ===")
                        print(f"Hourly data shape: {results['hourly_data'].shape}")
                        print(f"\nFirst 10 rows of hourly data:")
                        print(results['hourly_data'][['solar_mw', 'grid_sales_mw', 'price_per_mwh', 'revenue', 'net_revenue']].head(10))

                        print(f"\nRevenue column stats:")
                        print(f"  Min: ${results['hourly_data']['revenue'].min():,.2f}")
                        print(f"  Max: ${results['hourly_data']['revenue'].max():,.2f}")
                        print(f"  Mean: ${results['hourly_data']['revenue'].mean():,.2f}")
                        print(f"  Sum: ${results['hourly_data']['revenue'].sum():,.2f}")

                        print(f"\nGrid sales stats:")
                        print(f"  Total grid_sales_mw: {results['hourly_data']['grid_sales_mw'].sum():,.2f} MWh")
                        print(f"  Total solar_mw: {results['hourly_data']['solar_mw'].sum():,.2f} MWh")

                        print(f"\nResults dictionary values:")
                        print(f"  total_dollars: ${results['revenues']['total_dollars']:,.2f}")
                        print(f"  solar_only_dollars: ${results['revenues']['solar_only_dollars']:,.2f}")
                        print(f"  uplift_dollars: ${results['revenues']['uplift_dollars']:,.2f}")
                        print("==================\n")
                        
                        # 6. Store the results in the session state to persist them across reruns.
                        st.session_state['simulation_results'] = results
                        st.session_state['simulation_params'] = params
                        st.success("Simulation complete!")
                        
                except Exception as e:
                    # Catch any other unexpected errors during the process.
                    st.error(f"An error occurred during the simulation: {e}")
    
    # --- Display Results ---
    # Check if results exist in the session state before trying to display them.
    if 'simulation_results' in st.session_state:
        results = st.session_state['simulation_results']
        params = st.session_state['simulation_params']
        
        st.markdown("---")
        display_kpi_metrics(results, params)
        st.markdown("---")
        
        # Display the main visualization chart.
        st.subheader("Example Dispatch Visualization")
        
        # Create a date selector for the chart.
        available_dates = pd.Series(results['hourly_data'].index.date).unique()
        selected_date = st.selectbox(
            "Select a date to visualize",
            available_dates,
            help="Choose a specific day to see the detailed hourly dispatch strategy."
        )
        
        # Call the static method from the model class to create the chart.
        fig = SolarStorageArbitrage.create_arbitrage_chart(results, start_date=selected_date, num_days=1)
        st.plotly_chart(fig, use_container_width=True)
        
    else:
        # Display instructions if no simulation has been run yet.
        st.info("Use the controls in the sidebar to configure your system and click 'Run Simulation' to begin.")

if __name__ == "__main__":
    main()
