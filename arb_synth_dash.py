import streamlit as st
import pandas as pd
from datetime import datetime
from arbit import SolarStorageArbitrage

def create_sidebar_controls():
    """
    Creates the sidebar control panel for all user-configurable simulation inputs.
    
    Returns:
        dict: A dictionary containing all the parameters set by the user.
    """
    st.sidebar.header("Simulation Inputs")
    
    # --- Data and System Configuration ---
    st.sidebar.subheader("Market & System")
    price_market = st.sidebar.selectbox("Select Price Market", ["California (CAISO)", "Texas (ERCOT)"])
    solar_size_mw = st.sidebar.slider("Solar System Size (MW)", 50, 500, 100, 10)
    battery_power_mw = st.sidebar.slider("Battery Power (MW)", 25, 250, 50, 5)
    battery_duration_hours = st.sidebar.slider("Battery Duration (Hours)", 2, 6, 4, 1)
    
    # Derived parameter: Battery energy capacity is power * duration.
    battery_capacity_mwh = battery_power_mw * battery_duration_hours
    
    # --- Financial Assumptions ---
    st.sidebar.subheader("Financial Assumptions")
    battery_capex_per_kwh = st.sidebar.slider("Battery CAPEX ($/kWh)", 100, 250, 150, 25)
    round_trip_efficiency = st.sidebar.slider("Round-Trip Efficiency (%)", 80, 95, 90, 1) / 100.0
    
    # --- Action Button ---
    st.sidebar.markdown("---")
    run_simulation = st.sidebar.button("Run Simulation", type="primary", use_container_width=True)
    
    # Return all parameters in a dictionary.
    return {
        'price_market': price_market,
        'solar_size_mw': solar_size_mw,
        'battery_power_mw': battery_power_mw,
        'battery_capacity_mwh': battery_capacity_mwh,
        'battery_capex_per_kwh': battery_capex_per_kwh,
        'round_trip_efficiency': round_trip_efficiency,
        'run_simulation': run_simulation
    }

def display_kpi_metrics(results, params):
    """Displays the main Key Performance Indicators in a visually appealing way."""
    st.subheader("Key Performance Indicators")
    
    # Use columns for a clean layout.
    col1, col2, col3, col4 = st.columns(4)
    
    uplift = results['revenues']['uplift_dollars']
    uplift_pct = results['revenues']['uplift_percent']
    battery_cost = results['kpis']['battery_cost_dollars']
    payback = results['kpis']['payback_years']
    
    with col1:
        st.metric(
            "Annual Revenue Uplift",
            f"${uplift/1e6:.2f}M" if abs(uplift) >= 1e6 else f"${uplift:,.0f}",
            help="Additional annual revenue generated by adding the battery."
        )
    with col2:
        st.metric(
            "Revenue Increase",
            f"{uplift_pct:.1f}%",
            help="The percentage increase in total revenue compared to a standalone solar project."
        )
    with col3:
        st.metric(
            "Battery Investment",
            f"${battery_cost/1e6:.2f}M" if battery_cost >= 1e6 else f"${battery_cost:,.0f}",
            help="Total capital cost of the battery storage system."
        )
    with col4:
        if payback < 100:
            st.metric(
                "Simple Payback",
                f"{payback:.1f} years",
                help="Years to recover battery investment from net revenue uplift (after O&M costs)."
            )
        else:
            st.metric(
                "Simple Payback",
                "Not viable",
                help="Battery does not generate sufficient net revenue to pay back the investment."
            )
    
    # Second row with additional details
    st.markdown("---")
    col5, col6, col7, col8 = st.columns(4)
    
    solar_only = results['revenues']['solar_only_dollars']
    total_rev = results['revenues']['total_dollars']
    annual_om = results['kpis']['annual_om_dollars']
    net_benefit = results['kpis']['net_annual_benefit_dollars']
    
    with col5:
        st.metric(
            "Solar-Only Revenue",
            f"${solar_only/1e6:.2f}M" if solar_only >= 1e6 else f"${solar_only:,.0f}",
            help="Annual revenue from solar without battery storage."
        )
    with col6:
        st.metric(
            "Solar+Storage Revenue",
            f"${total_rev/1e6:.2f}M" if total_rev >= 1e6 else f"${total_rev:,.0f}",
            help="Total annual revenue with optimized battery arbitrage."
        )
    with col7:
        st.metric(
            "Annual O&M Cost",
            f"${annual_om/1e6:.2f}M" if annual_om >= 1e6 else f"${annual_om:,.0f}",
            help="Annual operations and maintenance cost (2.5% of battery capital cost)."
        )
    with col8:
        st.metric(
            "Net Annual Benefit",
            f"${net_benefit/1e6:.2f}M" if abs(net_benefit) >= 1e6 else f"${net_benefit:,.0f}",
            help="Revenue uplift minus annual O&M costs."
        )

def main():
    """
    Main function to configure the Streamlit page and orchestrate the
    simulation and display of results.
    """
    # --- Page Configuration ---
    st.set_page_config(
        page_title="Solar + Storage Arbitrage Calculator",
        page_icon="ðŸ”‹",
        layout="wide"
    )
    
    # --- Header ---
    st.title("Solar + Storage Arbitrage Value Calculator")
    st.markdown("""
    This tool quantifies the economic value of adding battery storage to a solar farm by simulating an 
    energy arbitrage strategy against realistic wholesale electricity price patterns.
    
    **Price Data:** Synthetic prices based on actual market behavior including seasonal variation, 
    duck curve patterns, and volatility typical of CAISO and ERCOT markets.
    """)
    
    # --- Sidebar and User Inputs ---
    params = create_sidebar_controls()
    
    # --- Simulation Execution Logic ---
    if params['run_simulation']:
        # Use a spinner to provide feedback during simulation.
        with st.spinner("Generating synthetic price data and running simulation..."):
            try:
                # 1. Initialize the model
                model = SolarStorageArbitrage()
                
                # 2. Load synthetic price data
                price_data = model.load_price_data(params['price_market'], year=2023)
                
                # 3. Check if price data was generated successfully
                if price_data is None or price_data.empty:
                    st.error("Failed to generate price data. Please try again.")
                    st.stop()
                
                # 4. Generate the corresponding solar profile
                solar_profile = model.generate_solar_profile(peak_mw=params['solar_size_mw'])
                
                # 5. Verify data alignment
                if len(solar_profile) != len(price_data):
                    st.error(f"Data mismatch: Solar profile has {len(solar_profile)} hours, price data has {len(price_data)} hours.")
                    st.stop()
                
                # 6. Run the core simulation
                results = model.run_simulation(solar_profile, params)


                print("\n=== DEBUG INFO ===")
                print(f"Hourly data shape: {results['hourly_data'].shape}")
                print(f"\nFirst 10 rows of hourly data:")
                print(results['hourly_data'][['solar_mw', 'grid_sales_mw', 'price_per_mwh', 'revenue', 'net_revenue']].head(10))

                print(f"\nRevenue column stats:")
                print(f"  Min: ${results['hourly_data']['revenue'].min():,.2f}")
                print(f"  Max: ${results['hourly_data']['revenue'].max():,.2f}")
                print(f"  Mean: ${results['hourly_data']['revenue'].mean():,.2f}")
                print(f"  Sum: ${results['hourly_data']['revenue'].sum():,.2f}")

                print(f"\nGrid sales stats:")
                print(f"  Total grid_sales_mw: {results['hourly_data']['grid_sales_mw'].sum():,.2f} MWh")
                print(f"  Total solar_mw: {results['hourly_data']['solar_mw'].sum():,.2f} MWh")

                print(f"\nResults dictionary values:")
                print(f"  total_dollars: ${results['revenues']['total_dollars']:,.2f}")
                print(f"  solar_only_dollars: ${results['revenues']['solar_only_dollars']:,.2f}")
                print(f"  uplift_dollars: ${results['revenues']['uplift_dollars']:,.2f}")
                print("==================\n")
                        
                
                # 7. Store the results in the session state to persist them across reruns
                st.session_state['simulation_results'] = results
                st.session_state['simulation_params'] = params
                st.success("âœ“ Simulation complete!")
                
            except Exception as e:
                # Catch any unexpected errors during the process
                st.error(f"An error occurred during the simulation: {str(e)}")
                import traceback
                st.code(traceback.format_exc())
    
    # --- Display Results ---
    # Check if results exist in the session state before trying to display them.
    if 'simulation_results' in st.session_state:
        results = st.session_state['simulation_results']
        params = st.session_state['simulation_params']
        
        st.markdown("---")
        display_kpi_metrics(results, params)
        st.markdown("---")
        
        # Display the main visualization chart.
        st.subheader("Example Dispatch Visualization")
        
        # Create a date selector for the chart.
        hourly_data = results['hourly_data']
        available_dates = sorted(list(set(hourly_data.index.date)))
        
        if available_dates:
            default_index = min(len(available_dates) - 1, 180)  # Default to ~6 months in
            
            selected_date = st.selectbox(
                "Select a date to visualize",
                available_dates,
                index=default_index,
                help="Choose a specific day to see the detailed hourly dispatch strategy."
            )
            
            # Call the static method from the model class to create the chart.
            try:
                fig = SolarStorageArbitrage.create_arbitrage_chart(
                    results, 
                    start_date=selected_date, 
                    num_days=1
                )
                st.plotly_chart(fig, use_container_width=True)
            except Exception as e:
                st.error(f"Error creating chart: {str(e)}")
        else:
            st.warning("No dates available for visualization.")
        
    else:
        # Display instructions if no simulation has been run yet.
        st.info("ðŸ‘ˆ Use the controls in the sidebar to configure your system and click 'Run Simulation' to begin.")

if __name__ == "__main__":
    main()